--track@A_t0:長さ,0,10000,300
--track@A_t1:Z内角,-360,360,0
--track@A_t2:Y内角,-360,360,0
--track@Xangle:ねじれ,-360,360,0
--value@BN:分割数,20
--value@wt:太さ,0
--check@maru:両端を丸める,0
--value@CHA:描画方法(0-4),0
--check@Ysw:Yスイッチ,0
--check@Ycv:Y曲げない,0
--check@Ocam:カメラ,0
--value@SEC:内部,0
--track@OCRRx:X軸,-360,360,0
--track@OCRRy:Y軸,-360,360,0
--track@OCRRz:Z軸,-360,360,0
--track@OCRR:内部,1,6,1,1
--track@r:半径,0,2000,150
--track@YShift:Y調整,-7200,7200,0
--track@per:縦横比,-1,1,0,0.01
--track@minR:極径下限,0,2000,0
--color@col:色,0xffff00
--value@h:縦分割(2-120),12;
--value@w:横分割(3-120),24
--value@alias:アンチエイリアス,1
--color@col2:靴色,0xffff00

rotShift = math.rad(YShift)
weight=wt/math.sqrt(2)
l=math.floor(weight)/2
-- check.
  XX={}
  YY={}
  ZZ={}
  TW={}
  XX[0]=0
  YY[0]=0
  ZZ[0]=0
      if Ycv==1 then
  TW[0]=A_t2
      else
  TW[0]=0
      end
  XX[1]=-A_t0/2
  YY[1]=A_t1/2
      if Ysw==1 and Ycv==0 then
      ZZ[1]=0
      else
      ZZ[1]=A_t2
      end
      if Ycv==1 then
  TW[1]=Xangle/2+A_t2
      else
  TW[1]=Xangle/2
      end
  XX[2]=-A_t0/2
  YY[2]=-A_t1/2
  ZZ[2]=A_t2
      if Ysw==1 and Ycv==0 then
  TW[2]=Xangle/2-A_t2
      elseif Ysw==0 and Ycv==1 then
  TW[2]=Xangle/2+A_t2
      else
  TW[2]=Xangle/2
      end
  NN=2
      if Ocam==1 then
cam = obj.getoption("camera_param") -- カメラデータの取得
local camr = 0
local cmrad,cmXds,cmZds = 0,0,0
local cmX = cam.x - cam.tx
local cmZ = cam.z - cam.tz
    cmXds = cmX+A_t2
    cmZds = cmZ+Xangle
cmrad = math.atan2(cmZds,cmXds)
camr = math.deg(-cmrad + math.pi/2)-180
  TW[0]=TW[0]+camr
  TW[1]=TW[1]+camr
  TW[2]=TW[2]+camr
      end

--三角形ポリゴン問題を防ぐために最小でも0.1になるように内部で強制調整
--（トラックで最小値を0.1としてもよいのだが、ドラッグで値を調整するときに
--　数値にコンマ１がつくのもなんか気持ち悪いかなと思って。）
minR = math.max( 0.1, minR )

  px,pz=1,1
  px=math.max(-per,0)
  pz=math.max(per,0)
  px,pz=1-px,1-pz

require("OCRUtil")

-- 関数共通
function PassXYZ(s) -- s<=1
  Ns=NN*s
  Ns1=math.floor(Ns)
  Ns2=(Ns-Ns1)/2

  if Ns1<=0 then
    nx=Ax[1]*Ns2*Ns2+Bx[1]*Ns2+Cx[1]
    ny=Ay[1]*Ns2*Ns2+By[1]*Ns2+Cy[1]
    nz=Az[1]*Ns2*Ns2+Bz[1]*Ns2+Cz[1]
    nt=At[1]*Ns2*Ns2+Bt[1]*Ns2+Ct[1]
  elseif Ns1==NN-1 then
    SS1=Ns2+0.5
    nx=Ax[Ns1]*SS1*SS1+Bx[Ns1]*SS1+Cx[Ns1]
    ny=Ay[Ns1]*SS1*SS1+By[Ns1]*SS1+Cy[Ns1]
    nz=Az[Ns1]*SS1*SS1+Bz[Ns1]*SS1+Cz[Ns1]
    nt=At[Ns1]*SS1*SS1+Bt[Ns1]*SS1+Ct[Ns1]
  elseif s==1 then
   nx=XX[NN]
   ny=YY[NN]
   nz=ZZ[NN]
   nt=TW[NN]
  else
    SS1=Ns2+0.5
    SS2=Ns2
    RS=2*Ns2
    nx=(Ax[Ns1]*SS1*SS1+Bx[Ns1]*SS1+Cx[Ns1])*(1-RS)+RS*(Ax[Ns1+1]*SS2*SS2+Bx[Ns1+1]*SS2+Cx[Ns1+1])
    ny=(Ay[Ns1]*SS1*SS1+By[Ns1]*SS1+Cy[Ns1])*(1-RS)+RS*(Ay[Ns1+1]*SS2*SS2+By[Ns1+1]*SS2+Cy[Ns1+1])
    nz=(Az[Ns1]*SS1*SS1+Bz[Ns1]*SS1+Cz[Ns1])*(1-RS)+RS*(Az[Ns1+1]*SS2*SS2+Bz[Ns1+1]*SS2+Cz[Ns1+1])
    nt=(At[Ns1]*SS1*SS1+Bt[Ns1]*SS1+Ct[Ns1])*(1-RS)+RS*(At[Ns1+1]*SS2*SS2+Bt[Ns1+1]*SS2+Ct[Ns1+1])
  end
  return nx,ny,nz,nt
end
function Sourcream(bz0,bz1,bz2,bz3,bx0,bx1,bx2,bx3)
  az={};ax={};
  az[0],az[1],az[2],az[3]=bz0,bz1,bz2,bz3
  ax[0],ax[1],ax[2],ax[3]=bx0,bx1,bx2,bx3
  for cn=0,3 do
    if(az[cn]>0) then
      az[cn]=az[cn]*0.75*px
    elseif(az[cn]<0) then
      az[cn]=az[cn]*2*px
    end
    ax[cn]=ax[cn]*pz
  end
  return az[0],az[1],az[2],az[3],ax[0],ax[1],ax[2],ax[3]
end
function ShiftR(iax,iay,iaz,ir)
  abs=(iax*iax+iay*iay)^0.5
  ibx,iby=iay/abs,-iax/abs
  icx,icy,icz=iax*iaz,iay*iaz,-iax*iax-iay*iay
  abs=(icx*icx+icy*icy+icz*icz)^0.5
  icx,icy,icz=icx/abs,icy/abs,icz/abs
  mc=math.cos(ir/180*math.pi)  
  ms=math.sin(ir/180*math.pi)
  return obj.w*(ibx*mc+icx*ms)/2,obj.w*(iby*mc+icy*ms)/2,obj.w*(icz*ms)/2
end

  for i=1,NN do
    s1=YY[i]*math.pi/180
    s2=(ZZ[i]+90)*math.pi/180
    XX[i],YY[i],ZZ[i]=XX[i]*math.sin(s1)*math.sin(s2),-XX[i]*math.cos(s1),-XX[i]*math.sin(s1)*math.cos(s2)
  end

-- --------以降共通
  for i=1,NN do
    XX[i]=XX[i-1]+XX[i]
    YY[i]=YY[i-1]+YY[i]
    ZZ[i]=ZZ[i-1]+ZZ[i]
  end

  OFH=(1+obj.frame)/(1+obj.totalframe)

  Ax={};Bx={};Cx={};
  Ay={};By={};Cy={};
  Az={};Bz={};Cz={};
  At={};Bt={};Ct={};

  for M=1,NN-1 do
    Ax[M]=2*XX[M-1]-4*XX[M]+2*XX[M+1]
    Bx[M]=-3*XX[M-1]+4*XX[M]-XX[M+1] 
    Cx[M]=XX[M-1]
    Ay[M]=2*YY[M-1]-4*YY[M]+2*YY[M+1]
    By[M]=-3*YY[M-1]+4*YY[M]-YY[M+1] 
    Cy[M]=YY[M-1]
    Az[M]=2*ZZ[M-1]-4*ZZ[M]+2*ZZ[M+1]
    Bz[M]=-3*ZZ[M-1]+4*ZZ[M]-ZZ[M+1] 
    Cz[M]=ZZ[M-1]
    At[M]=2*TW[M-1]-4*TW[M]+2*TW[M+1]
    Bt[M]=-3*TW[M-1]+4*TW[M]-TW[M+1] 
    Ct[M]=TW[M-1]
  end

  if CHA==0 then
    Nmax=NN*BN
    Nv=Nmax
    Ama=0
  elseif CHA==1 then
    Nmax=math.floor(NN*BN*OFH)
    Nv=NN*BN
    Ama=NN*BN*OFH-Nmax
  elseif CHA==2 then
    Nmax=math.floor(NN*BN*OFH)
    Nv=Nmax
    Ama=NN*BN*OFH-Nmax
  elseif CHA==3 then 
    Nmax=math.floor(NN*BN*OFH)
  else
    Nmax=NN*BN
  end

if l>0 then
--ライン描画
obj.load("figure","四角形",col,l*8)
  if OCRRikky==1 then
	obj.ox,obj.oy,obj.oz=OCRRikkyx,OCRRikkyy,OCRRikkyz
	obj.rx,obj.ry,obj.rz=OCRRikkyrx,OCRRikkyry,OCRRikkyrz
  end
obj.effect()

if CHA<3 then
ocr_fd={}
  xf,yf,zf,tf = PassXYZ(0)
  ix,iy,iz,it =PassXYZ(0.5/(NN*BN))
  dx,dy,dz= ShiftR(ix-xf,iy-yf,iz-zf,TW[0])
  x1,y1,z1 = xf+dx,yf+dy,zf+dz
  x0,y0,z0 = xf-dx,yf-dy,zf-dz
    for i=1,Nmax do
      ix,iy,iz,it =PassXYZ(i/(NN*BN))
      dx,dy,dz= ShiftR(ix-xf,iy-yf,iz-zf,it)
      x2,y2,z2=ix+dx,iy+dy,iz+dz
      x3,y3,z3=ix-dx,iy-dy,iz-dz
      v1=obj.h*(1-(i)/(Nv+Ama))
      v2=obj.h*(1-(i-1)/(Nv+Ama))
      if SEC==1 then
        table.insert(ocr_fd,{y0,z0,x0, y1,z1,x1, y2,z2,x2, y3,z3,x3, 0,v2, obj.w,v2, obj.w,v1, 0,v1})
      elseif SEC==2 then
        table.insert(ocr_fd,{z0,y0,x0, z1,y1,x1, z2,y2,x2, z3,y3,x3, 0,v2, obj.w,v2, obj.w,v1, 0,v1})
      else
        table.insert(ocr_fd,{x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3, 0,v2, obj.w,v2, obj.w,v1, 0,v1})
      end
      x0,y0,z0=x3,y3,z3
      x1,y1,z1=x2,y2,z2
      xf,yf,zf=ix,iy,iz
    end -- i
  if Ama>0 then
    ix,iy,iz,it =PassXYZ((Nmax+Ama)/(NN*BN))
    dx,dy,dz= ShiftR(ix-xf,iy-yf,iz-zf,it)
    x2,y2,z2=ix+dx,iy+dy,iz+dz
    x3,y3,z3=ix-dx,iy-dy,iz-dz
    v1=obj.h*(1-(Nmax+Ama)/(Nv+Ama))
    v2=obj.h*(1-Nmax/(Nv+Ama))
    if SEC==1 then
      table.insert(ocr_fd,{y0,z0,x0, y1,z1,x1, y2,z2,x2, y3,z3,x3, 0,v2, obj.w,v2, obj.w,v1, 0,v1})
    elseif SEC==2 then
      table.insert(ocr_fd,{z0,y0,x0, z1,y1,x1, z2,y2,x2, z3,y3,x3, 0,v2, obj.w,v2, obj.w,v1, 0,v1})
    else
      table.insert(ocr_fd,{x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3, 0,v2, obj.w,v2, obj.w,v1, 0,v1})
    end
  end
  obj.drawpoly(ocr_fd)
else -- cha<3
  for i=0,Nmax do
    obj.ox , obj.oy , obj.oz ,NL =PassXYZ(i/(NN*BN))
    obj.draw()
  end
end

--頂点の描画
if maru==1 then
ocr_fd={}
  obj.load("figure","円",col,l*8)
  if OCRRikky==1 then
	obj.ox,obj.oy,obj.oz=OCRRikkyx,OCRRikkyy,OCRRikkyz
	obj.rx,obj.ry,obj.rz=OCRRikkyrx,OCRRikkyry,OCRRikkyrz
  end
  obj.effect()
  cw=l*4
  for i=0,1 do
    ix,iy,iz,it =PassXYZ(i/NN)
    if SEC==1 then
      table.insert(ocr_fd,{iy+cw,iz,ix+cw, iy+cw,iz,ix-cw, iy-cw,iz,ix-cw, iy-cw,iz,ix+cw, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h})
    elseif SEC==2 then
      table.insert(ocr_fd,{iz,iy+cw,ix+cw, iz,iy+cw,ix-cw, iz,iy-cw,ix-cw, iz,iy-cw,ix+cw, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h})
    else
      table.insert(ocr_fd,{ix+cw,iy+cw,iz, ix-cw,iy+cw,iz, ix-cw,iy-cw,iz, ix+cw,iy-cw,iz, 0,0, obj.w,0, obj.w,obj.h, 0,obj.h})
    end
  end -- i
end
  obj.drawpoly(ocr_fd)
end
-- ---------ここから違う
--先端描画
ocr_fd={}
  obj.load("figure","四角形",col2,r*2)
obj.setoption('antialias',alias)
obj.effect()

local OCRsx,OCRsy,OCRsz,OCRsrx,OCRsry,OCRsrz
debug_print(string.format("OFH = %d, NN = %d, BN = %d",OFH,NN,BN))
debug_print(string.format("Nmax = %d, Ama = %d, Nv = %d",Nmax,Ama,Nv))

  if NN*BN*OFH<=1/2 then
    inm=1/2
  else
    inm=NN*BN*OFH
  end

  if CHA==0 then inm=NN*BN end

  xp,yp,zp,it = PassXYZ(inm/(NN*BN))
  
  if SEC==1 then
    OCRsx = yp
    OCRsy = zp
    OCRsz = xp
  elseif SEC==2 then
    OCRsx = zp
    OCRsy = yp
    OCRsz = xp
  else
    OCRsx = xp
    OCRsy = yp
    OCRsz = zp
  end
 
  if OCRR>0 then
local OCRDx,OCRDy,OCRDz,OCRsrx,OCRsry,OCRsrz
  if OCRRikky==1 then
  OCRsrx,OCRsry,OCRsrz = OCRRikkyrx,OCRRikkyrx,OCRRikkyrz
  OCRDx=math.rad(OCRRikkyrx)
  OCRDy=math.rad(OCRRikkyry)
  OCRDz=math.rad(OCRRikkyrz)
  else
  OCRsrx,OCRsry,OCRsrz = obj.rx,obj.ry,obj.rz
  if OCRsrx==nil then OCRsrx = 0 end
  if OCRsry==nil then OCRsry = 0 end
  
   OCRDx=math.rad(OCRsrx)
   OCRDy=math.rad(OCRsry)
   OCRDz=math.rad(OCRsrz)
  end
debug_print(string.format("sx = %d, sy = %d, sz = %d",OCRsx,OCRsy,OCRsz))
    if OCRR%2==1 then
		obj.rx,obj.ry,obj.rz=OCRsrx + OCRRz,OCRsry + OCRRy,OCRsrz + OCRRx
    else
		obj.rx,obj.ry,obj.rz=OCRsrx + OCRRx,OCRsry + OCRRy,OCRsrz + OCRRz
    end
  OCRx,OCRy,OCRz=OCRRoll(OCRsx,OCRsy,OCRsz,OCRDx,OCRDy,OCRDz)
  end
  if OCRRikky==1 then
	obj.ox,obj.oy,obj.oz=OCRx+OCRRikkyx,OCRy+OCRRikkyy+YShift,OCRz+OCRRikkyz
  else
	obj.ox,obj.oy,obj.oz=OCRx+obj.ox,OCRy+obj.oy+YShift,OCRz+obj.oz
  end
  
w = math.max( 3, math.min( 120, math.floor(w) ) )
h = math.max( 2, math.min( 120, math.floor(h) ) )

deltaH = math.rad(180/h)
deltaW = math.rad(360/w)
deltaU = obj.w/w
deltaV = obj.h/h

for y=0,h-1 do
  rotH0 = deltaH*y
  rotHC = rotH0 + deltaH/2
  rotH1 = rotH0 + deltaH

  y0 = math.min( 0, (-r*math.cos(rotH0)) )
  y1 = math.min( 0, (-r*math.cos(rotH1)) )

  -- r0とr1をminRで下限制御
  r0 =  math.max( minR, (r*math.sin(rotH0)) )
  r1 =  math.max( minR, (r*math.sin(rotH1)) )

  v0 = deltaV*y
  v1 = deltaV*(y+1)

  for x=0,w-1 do
    rotW0= -deltaW*x + rotShift
    rotWC = rotW0 - deltaW/2
    rotW1 = rotW0 - deltaW

    x0 =  r0*math.sin(rotW0)
    x1 =  r0*math.sin(rotW1)
    x2 =  r1*math.sin(rotW1)
    x3 =  r1*math.sin(rotW0)
    z0 =  r0*math.cos(rotW0)
    z1 =  r0*math.cos(rotW1)
    z2 =  r1*math.cos(rotW1)
    z3 =  r1*math.cos(rotW0)
    if OCRR>=5 then
    x0,x1,x2,x3,z0,z1,z2,z3=Sourcream(x0,x1,x2,x3,z0,z1,z2,z3)
    x0,x1,x2,x3=x0*-1,x1*-1,x2*-1,x3*-1
    elseif OCRR-2<1 then
    z0,z1,z2,z3,x0,x1,x2,x3=Sourcream(x0,x1,x2,x3,z0,z1,z2,z3)
    x0,x1,x2,x3=x0*-1,x1*-1,x2*-1,x3*-1
    else
    x0,x1,x2,x3,z0,z1,z2,z3=Sourcream(x0,x1,x2,x3,z0,z1,z2,z3)
    end
    u0 = deltaU*x
    u1 = deltaU*(x+1)
    table.insert(ocr_fd,{x0,y0,z0,x1,y0,z1,x2,y1,z2,x3,y1,z3,u0,v0,u1,v0,u1,v1,u0,v1})
  end
end
  obj.drawpoly(ocr_fd)
  if OCRR>0 then
  OCRR=0
  end
  if OCRRikky==1 then
  OCRRikky=0
  end
