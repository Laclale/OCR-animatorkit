@眉
--track@eyemg:左右幅,1,2000,100,1
--track@eyeang:角度,0,90,45
--track@ebstartr:右眉始点,-90,90,0
--track@ebstartl:左眉始点,-90,90,0
--track@ebendr:右眉終点,-90,90,0
--track@ebendl:左眉終点,-90,90,0
--track@ebflipr:右眉反転,0,1,0,1
--track@ebflipl:左眉反転,0,1,0,1
--color@ebcl:色,0x000000
--value@BN:分割数,20
--value@lnper:長さ/分割,5
--value@ebper:幅減少/分割,1
--value@line:終点幅,0.1
--check@maru:両端を丸くする,0

BN,lnper=math.max(BN,0),math.max(lnper,0)
ebper,line=math.max(ebper,0),math.max(line,0)
local ebstart={ebstartr,ebstartl}
local ebend={ebendr,ebendl}
local ebflip={ebflipr,ebflipl}
  local s=BN*lnper

require("OCRUtil")
function ocr_insertuv(tbl,u0,v0,u1,v1,u2,v2,u3,v3)
	table.insert(tbl,u0)
	table.insert(tbl,v0)
	table.insert(tbl,u1)
	table.insert(tbl,v1)
	table.insert(tbl,u2)
	table.insert(tbl,v2)
	table.insert(tbl,u3)
	table.insert(tbl,v3)
	return tbl
end
for i=0,1 do
local ln = line+ebper*BN
local sw,sh = s*2 + ln+line*2, s*3 + ln+line
obj.setoption("drawtarget","tempbuffer",sw,sh)
ocr_fd={}
ocr_circlepaste={}
obj.load("figure","四角形",ebcl,s)
obj.effect()
obj.setoption("blend","alpha_max")

local ebx,eby,ly = ln/2,obj.h/2,obj.h/BN
local eba,ebtilt = ebstart[i+1]-90,(ebend[i+1] - ebstart[i+1])/BN
local uy,uy2=0,ly
local eblx, ebly = anglepoint90(eba,ln)
if maru then
local m_ebx, m_eby = anglepoint(ebx,eby,eba,-ebx)
table.insert(ocr_circlepaste,{
m_ebx-eblx,m_eby-ebly,0,
m_ebx+eblx,m_eby+ebly,0,
ebx+eblx,eby+ebly,0,
ebx-eblx,eby-ebly,0})
end
for j=1,BN do
eba = eba + ebtilt
ln = ln - ebper
local ebx2, eby2 = anglepoint(ebx,eby,eba,lnper)
local eblx2, ebly2 = anglepoint90(eba,ln)
--anglepoint(px,py,angle,dist) dx,dy
--anglepoint90(angle,size) dx,dy
table.insert(ocr_fd,{ebx-eblx,eby-ebly,0,ebx+eblx,eby+ebly,0,ebx2+eblx2,eby2+ebly2,0,ebx2-eblx2,eby2-ebly2,0,0,uy, obj.w,uy, obj.w,uy2, 0,uy2})
uy,uy2=uy + ly, uy2 + ly
ebx, eby = ebx2, eby2
eblx, ebly = eblx2, ebly2
end
if maru then
local m_ebx, m_eby = anglepoint(ebx,eby,eba,line)
table.insert(ocr_circlepaste,{ebx-eblx,eby-ebly,0,ebx+eblx,eby+ebly,0,m_ebx+eblx,m_eby+ebly,0,m_ebx-eblx,m_eby-ebly,0})
end
obj.drawpoly(ocr_fd)
if maru then
obj.load("figure","円",ebcl,line+ebper*BN)
local cu, cv, cvh = obj.w, obj.h/2, obj.h
ocr_insertuv(ocr_circlepaste[1],0,0,cu,cv,cu,cv,0,0)
ocr_insertuv(ocr_circlepaste[2],0,cv,cu,cvh,cu,cvh,0,cv)
obj.drawpoly(ocr_circlepaste)
end
obj.setoption("blend",0)
obj.setoption("drawtarget","framebuffer")
obj.load("tempbuffer")
--片目完成
local it = 2*i-1
local x=obj.w
local qy=obj.h/2
obj.effect()
qz,qx=anglepoint90((90-eyeang)*it,x+line)
epx,qz=eyemg/2*it,-qz
if ( ebflip[i+1] == 1 ) then
	obj.effect("反転","左右反転",1)
end
  if ( i == 0 ) then
	obj.drawpoly(epx-qx,-qy,-qz,epx+qx,-qy,qz,epx+qx,qy,qz,epx-qx,qy,-qz)
  else
	obj.drawpoly(epx+qx,-qy,qz,epx-qx,-qy,-qz,epx-qx,qy,-qz,epx+qx,qy,qz)
  end
end
@C_目
--track@eyemg:左右幅,1,1000,100,1
--track@eyeang:角度,0,90,45
--track@eyetyper:右目,0,14,0,1
--track@eyetypel:左目,0,14,0,1
--color@eyecl:色,0x000000
--value@s:目の大きさ,50
--value@per:目の縦横比,-50
--value@line:閉じ目幅,0
--c_num:C親番号,1,100,1,1
--check@lowa:親下,0

  local epx,epy=1,1
  epx,epy=math.max(-per,0),math.max(per,0)
  epx,epy=math.min(100,epx)/100,math.min(100,epy)/100
  epx,epy=1-epx,1-epy

--forループ内で使う変数をループの外に宣言します
local i, ln, x, y, ux,uy, lx, ly,it,eyex,qx,qy,qz,sw,sh

require("rikky_parent_control")
require("OCRUtil")
if lowa then
	rikky_underparent()
end
--親番号のテーブルを子供としてローカル変数にコピーします
local child_info = r_parent_info[math.ceil(c_num)]

--各情報をローカル変数にコピーします
local ozoom = child_info.zoom

--親の拡大率を子供の移動量にかけます
--理屈は面倒ですが、要は子供の座標に親を足すので親の拡大率が子供の位置に影響するとかとかとか…
local dx = (obj.getvalue("x") + obj.ox) * ozoom
local dy = (obj.getvalue("y") + obj.oy) * ozoom
local dz = (obj.getvalue("z") + obj.oz) * ozoom

--角度が度数法なので、それを弧度法に変換します
local pi_180 = math.pi / 180
local rz = child_info.rz * pi_180
local ry = child_info.ry * pi_180
local rx = child_info.rx * pi_180

--下準備継続
local cos = math.cos(rz)
local sin = math.sin(rz)
local x1 = dx * cos - dy * sin
local y1 = dx * sin + dy * cos
local eyerx, eyery, eyerz = obj.rx, obj.ry, obj.rz
obj.rx, obj.ry, obj.rz = 0,0,0
local eyezoom = obj.zoom
local eyealpha = obj.alpha
obj.ox,obj.oy,obj.oz = 0,0,0

--仮想バッファサイズ計算
local _sw,_sh = s*epx,s*epy
for i=0,1 do
sw,sh = _sw,_sh
  if(eyetype[i+1] == 6) then
    sw = sw*1.5
  elseif btween(eyetype[i+1],7,8) then
    sw,sh = sw*2.5,sh+line*2
  elseif btween(eyetype[i+1],9,12) then
    sw = sw*2.5
  else
    sw,sh = sw+line,sh+line
  end
ln = line/2
obj.setoption("drawtarget","tempbuffer",sw,sh)

obj.load("figure","円",eyecl,s)
x=obj.w/2*epx
y=obj.h/2*epy
ux,uy=obj.w,obj.h
lx = (obj.w/2-ln)/2
ly = (obj.h/2-ln)/2
debug_print(string.format("x = %d, obj.w = %d, epx = %d",x,obj.w,epx))
obj.setoption("blend","alpha_max")
if(eyetype[i+1] == 1) then
obj.drawpoly(-x,ly-ln-y, 0,x,ly-ln-y, 0,x,ly-ln+y, 0,-x,ly-ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,ly+ln-y, 0,x,ly+ln-y, 0,x,ly+ln+y, 0,-x,ly+ln+y, 0)
elseif(eyetype[i+1] == 2) then
obj.drawpoly(-x,-ly+ln-y, 0,x,-ly+ln-y, 0,x,-ly+ln+y, 0,-x,-ly+ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,-ly-ln-y, 0,x,-ly-ln-y, 0,x,-ly-ln+y, 0,-x,-ly-ln+y, 0)
elseif(eyetype[i+1] == 3) then
obj.drawpoly(-lx+ln-x*2,-y*3/4, 0,-lx+ln+x,-y*3/4, 0,-lx+ln+x,y*3/4, 0,-lx+ln-x*2,y*3/4, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x*2,-y*3/4, 0,-lx-ln+x,-y*3/4, 0,-lx-ln+x,y*3/4, 0,-lx-ln-x*2,y*3/4, 0)
elseif(eyetype[i+1] == 4) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(ln-x,ln-y, 0,x-ln,ln-y, 0,x-ln,y-ln, 0,ln-x,y, 0)
elseif(eyetype[i+1] == 5) then
obj.drawpoly(-lx+ln-x,-y, 0,-lx+ln+x,-y, 0,-lx+ln+x,y, 0,-lx+ln-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x,-y, 0,-lx-ln+x,-y, 0,-lx-ln+x,y, 0,-lx-ln-x,y, 0)
elseif(eyetype[i+1] == 6) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
elseif(eyetype[i+1] == 7) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,-x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 8) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 9) then
obj.drawpoly(-x,-y+y/8, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,uy/16,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,-x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(x/2,-y+y/4-ln, 0,-x/6,-y+y/4-ln, 0,-x/6,-y+y/4+ln, 0,x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 10) then
obj.drawpoly(-x,-y+y/4, 0,x,-y+y/8, 0,x,y,0,-x,y,0, 0,uy/8,ux,uy/16,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(-x/2,-y+y/4-ln, 0,x/6,-y+y/4-ln, 0,x/6,-y+y/4+ln, 0,-x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 11) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/8+ln, 0,-x/6,-y+y/8, 0,-x/6,-y+y/8+line, 0,-x*2.5,-y+y/8+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 12) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4+ln, 0,0,-y+y/8, 0,0,-y+y/8+line, 0,x*2.5,-y+y/4+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 13) then
obj.drawpoly(-x,-x/2, 0,x,-x/2, 0,x,x/2, 0,-x,x/2, 0)
elseif(eyetype[i+1] == 14) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
obj.drawpoly(-x*1.5,y-line*2, 0,x*1.5,y-line*2, 0,x*1.5,y, 0,-x*1.5,y, 0)
else
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
end
obj.setoption("blend",0)
obj.setoption("drawtarget","framebuffer")
--片目完成
obj.load("tempbuffer")
obj.effect()
--親の軸回転を実行します
--回転させる軸の順番は大事です
cos = math.cos(ry)
sin = math.sin(ry)
local z1 = dz * cos - x1 * sin
--軸回転させた結果と親の位置のx、y、zの位置を相対位置に代入します
--トラックバーの値を引くのは計算には必要でも、描画には必要ないからです
obj.ox = -obj.getvalue("x") + (dz * sin + x1 * cos) + child_info.x
cos = math.cos(rx)
sin = math.sin(rx)
obj.oy = -obj.getvalue("y") + (y1 * cos - z1 * sin) + child_info.y
obj.oz = -obj.getvalue("z") + (y1 * sin + z1 * cos) + child_info.z

--r_P_C_ROTATION関数はluaファイルで作った関数です
--親と子の回転を一つにまとめるのが関数の役割です
obj.rx, obj.ry, obj.rz = r_P_C_ROTATION(eyerx, eyery, eyerz, child_info.rx, child_info.ry, child_info.rz)

--拡大率と透明度は単純にかけるだけです
obj.zoom = eyezoom * ozoom
obj.alpha = eyealpha * child_info.alpha
if child_info.disp then
	--obj.effect("単色化", "color", 0xff0000)
	--obj.effect("色調補正", "色相", math.ceil(c_num) * 15)
	r_P_C_DISP(math.ceil(c_num), "c")
end

--ここから描画を実行していきます
it = 2*i-1
eyex=obj.w
qy=obj.h/2
qz,qx=anglepoint90((90-eyeang)*it,eyex+line)
eyex,qz=eyemg/2*it,-qz
  if ( i == 0 ) then
	obj.drawpoly(eyex-qx,-qy,-qz,eyex+qx,-qy,qz,eyex+qx,qy,qz,eyex-qx,qy,-qz)
  else
	obj.effect("反転","左右反転",1)
	obj.drawpoly(eyex+qx,-qy,qz,eyex-qx,-qy,-qz,eyex-qx,qy,-qz,eyex+qx,qy,qz)
  end
end
@Shooty目
--track@eyemg:左右幅,1,1000,100,1
--track@eyetyper:右目,0,14,0,1
--track@eyetypel:左目,0,14,0,1
--color@eyecl:色,0x000000
--value@s:目の大きさ,50
--value@per:目の縦横比,-50
--check@blink:まばたき,0
--value@line:閉じ目幅,0

eyetype={eyetyper,eyetypel}

  px,py=1,1
  px,py=math.max(-per,0),math.max(per,0)
  px,py=math.min(100,px)/100,math.min(100,py)/100
  px,py=1-px,1-py

require("OCRUtil")

--仮想バッファサイズ計算
sw,sh = s*px,s*py
for i=0,1 do
  if(eyetype[i+1] == 6) then
    sw = sw*1.5
  elseif btween(eyetype[i+1],7,8) then
    sw,sh = sw*2.5,sh+line*2
  elseif btween(eyetype[i+1],9,12) then
    sw = sw*2.5
  else
    sw,sh = sw+line,sh+line
  end
local ln = line/2
obj.setoption("drawtarget","tempbuffer",sw,sh)

obj.load("figure","円",eyecl,s)
x=obj.w/2*px
y=obj.h/2*py
local ux,uy=obj.w,obj.h
local lx = (obj.w/2-ln)/2
local ly = (obj.h/2-ln)/2
obj.setoption("blend","alpha_max")
if(eyetype[i+1] == 1) then
obj.drawpoly(-x,ly-ln-y, 0,x,ly-ln-y, 0,x,ly-ln+y, 0,-x,ly-ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,ly+ln-y, 0,x,ly+ln-y, 0,x,ly+ln+y, 0,-x,ly+ln+y, 0)
elseif(eyetype[i+1] == 2) then
obj.drawpoly(-x,-ly+ln-y, 0,x,-ly+ln-y, 0,x,-ly+ln+y, 0,-x,-ly+ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,-ly-ln-y, 0,x,-ly-ln-y, 0,x,-ly-ln+y, 0,-x,-ly-ln+y, 0)
elseif(eyetype[i+1] == 3) then
obj.drawpoly(-lx+ln-x*2,-y*3/4, 0,-lx+ln+x,-y*3/4, 0,-lx+ln+x,y*3/4, 0,-lx+ln-x*2,y*3/4, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x*2,-y*3/4, 0,-lx-ln+x,-y*3/4, 0,-lx-ln+x,y*3/4, 0,-lx-ln-x*2,y*3/4, 0)
elseif(eyetype[i+1] == 4) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(ln-x,ln-y, 0,x-ln,ln-y, 0,x-ln,y-ln, 0,ln-x,y, 0)
elseif(eyetype[i+1] == 5) then
obj.drawpoly(-lx+ln-x,-y, 0,-lx+ln+x,-y, 0,-lx+ln+x,y, 0,-lx+ln-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x,-y, 0,-lx-ln+x,-y, 0,-lx-ln+x,y, 0,-lx-ln-x,y, 0)
elseif(eyetype[i+1] == 6) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
elseif(eyetype[i+1] == 7) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,-x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 8) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 9) then
obj.drawpoly(-x,-y+y/8, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,uy/16,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,-x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(x/2,-y+y/4-ln, 0,-x/6,-y+y/4-ln, 0,-x/6,-y+y/4+ln, 0,x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 10) then
obj.drawpoly(-x,-y+y/4, 0,x,-y+y/8, 0,x,y,0,-x,y,0, 0,uy/8,ux,uy/16,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(-x/2,-y+y/4-ln, 0,x/6,-y+y/4-ln, 0,x/6,-y+y/4+ln, 0,-x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 11) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/8+ln, 0,-x/6,-y+y/8, 0,-x/6,-y+y/8+line, 0,-x*2.5,-y+y/8+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 12) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4+ln, 0,0,-y+y/8, 0,0,-y+y/8+line, 0,x*2.5,-y+y/4+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 13) then
obj.drawpoly(-x,-x/2, 0,x,-x/2, 0,x,x/2, 0,-x,x/2, 0)
elseif(eyetype[i+1] == 14) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
obj.drawpoly(-x*1.5,y-line*2, 0,x*1.5,y-line*2, 0,x*1.5,y, 0,-x*1.5,y, 0)
else
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
end

obj.setoption("blend",0)
obj.setoption("drawtarget","framebuffer")
obj.load("tempbuffer")
--片目完成
local it = 2*i-1
local x=obj.w
local qy=obj.h/2
obj.effect()
qz=x+line
epx,qz=eyemg/2*it,-qz
  if ( i == 0 ) then
	obj.drawpoly(epx,-qy,-qz,epx,-qy,qz,epx,qy,qz,epx,qy,-qz)
  else
	obj.effect("反転","左右反転",1)
	obj.drawpoly(epx,-qy,qz,epx,-qy,-qz,epx,qy,-qz,epx,qy,qz)
  end
end
@目
--track@eyemg:左右幅,1,1000,100,1
--track@eyeang:角度,0,90,45
--track@eyetyper:右目,0,14,0,1
--track@eyetypel:左目,0,14,0,1
--color@eyecl:色,0x000000
--value@s:目の大きさ,50
--value@per:目の縦横比,-50
--check@blink:まばたき,0
--value@line:閉じ目幅,0

eyetype={eyetyper,eyetypel}

  px,py=1,1
  px,py=math.max(-per,0),math.max(per,0)
  px,py=math.min(100,px)/100,math.min(100,py)/100
  px,py=1-px,1-py

require("OCRUtil")

--仮想バッファサイズ計算
sw,sh = s*px,s*py
for i=0,1 do
  if(eyetype[i+1] == 6) then
    sw = sw*1.5
  elseif btween(eyetype[i+1],7,8) then
    sw,sh = sw*2.5,sh+line*2
  elseif btween(eyetype[i+1],9,12) then
    sw = sw*2.5
  else
    sw,sh = sw+line,sh+line
  end
local ln = line/2
obj.setoption("drawtarget","tempbuffer",sw,sh)

obj.load("figure","円",eyecl,s)
x=obj.w/2*px
y=obj.h/2*py
local ux,uy=obj.w,obj.h
local lx = (obj.w/2-ln)/2
local ly = (obj.h/2-ln)/2
obj.setoption("blend","alpha_max")
if(eyetype[i+1] == 1) then
obj.drawpoly(-x,ly-ln-y, 0,x,ly-ln-y, 0,x,ly-ln+y, 0,-x,ly-ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,ly+ln-y, 0,x,ly+ln-y, 0,x,ly+ln+y, 0,-x,ly+ln+y, 0)
elseif(eyetype[i+1] == 2) then
obj.drawpoly(-x,-ly+ln-y, 0,x,-ly+ln-y, 0,x,-ly+ln+y, 0,-x,-ly+ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,-ly-ln-y, 0,x,-ly-ln-y, 0,x,-ly-ln+y, 0,-x,-ly-ln+y, 0)
elseif(eyetype[i+1] == 3) then
obj.drawpoly(-lx+ln-x*2,-y*3/4, 0,-lx+ln+x,-y*3/4, 0,-lx+ln+x,y*3/4, 0,-lx+ln-x*2,y*3/4, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x*2,-y*3/4, 0,-lx-ln+x,-y*3/4, 0,-lx-ln+x,y*3/4, 0,-lx-ln-x*2,y*3/4, 0)
elseif(eyetype[i+1] == 4) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(ln-x,ln-y, 0,x-ln,ln-y, 0,x-ln,y-ln, 0,ln-x,y, 0)
elseif(eyetype[i+1] == 5) then
obj.drawpoly(-lx+ln-x,-y, 0,-lx+ln+x,-y, 0,-lx+ln+x,y, 0,-lx+ln-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x,-y, 0,-lx-ln+x,-y, 0,-lx-ln+x,y, 0,-lx-ln-x,y, 0)
elseif(eyetype[i+1] == 6) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
elseif(eyetype[i+1] == 7) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,-x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 8) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 9) then
obj.drawpoly(-x,-y+y/8, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,uy/16,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,-x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(x/2,-y+y/4-ln, 0,-x/6,-y+y/4-ln, 0,-x/6,-y+y/4+ln, 0,x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 10) then
obj.drawpoly(-x,-y+y/4, 0,x,-y+y/8, 0,x,y,0,-x,y,0, 0,uy/8,ux,uy/16,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(-x/2,-y+y/4-ln, 0,x/6,-y+y/4-ln, 0,x/6,-y+y/4+ln, 0,-x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 11) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/8+ln, 0,-x/6,-y+y/8, 0,-x/6,-y+y/8+line, 0,-x*2.5,-y+y/8+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 12) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4+ln, 0,0,-y+y/8, 0,0,-y+y/8+line, 0,x*2.5,-y+y/4+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 13) then
obj.drawpoly(-x,-x/2, 0,x,-x/2, 0,x,x/2, 0,-x,x/2, 0)
elseif(eyetype[i+1] == 14) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
obj.drawpoly(-x*1.5,y-line*2, 0,x*1.5,y-line*2, 0,x*1.5,y, 0,-x*1.5,y, 0)
elseif(eyetype[i+1] == 15) then
obj.drawpoly(-y/4,-x/2, 0,y/4,-x/2, 0,y/4,x/2, 0,-y/4,x/2, 0)
else
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
end

obj.setoption("blend",0)
obj.setoption("drawtarget","framebuffer")
obj.load("tempbuffer")
--片目完成
local it = 2*i-1
local x=obj.w
local qy=obj.h/2
obj.effect()
qz,qx=anglepoint90((90-eyeang)*it,x+line)
epx,qz=eyemg/2*it,-qz
  if ( i == 0 ) then
	obj.drawpoly(epx-qx,-qy,-qz,epx+qx,-qy,qz,epx+qx,qy,qz,epx-qx,qy,-qz)
  else
	obj.effect("反転","左右反転",1)
	obj.drawpoly(epx+qx,-qy,qz,epx-qx,-qy,-qz,epx-qx,qy,-qz,epx+qx,qy,qz)
  end
end
@オッドアイ
--track@eyemg:左右幅,1,1000,100,1
--track@eyeang:角度,0,90,45
--track@eyetyper:右目,0,14,0,1
--track@eyetypel:左目,0,14,0,1
--color@eyeright:右目色,0x000000
--color@eyeleft:左目色,0x000000
--value@s:目の大きさ,50
--value@per:目の縦横比,-50
--check@blink:まばたき,0
--value@line:閉じ目幅,0

eyetype={eyetyper,eyetypel}
eyecl={eyeright,eyeleft}

  px,py=1,1
  px,py=math.max(-per,0),math.max(per,0)
  px,py=math.min(100,px)/100,math.min(100,py)/100
  px,py=1-px,1-py

require("OCRUtil")

--仮想バッファサイズ計算
sw,sh = s*px,s*py
for i=0,1 do
  if(eyetype[i+1] == 6) then
    sw = sw*1.5
  elseif btween(eyetype[i+1],7,8) then
    sw,sh = sw*2.5,sh+line*2
  elseif btween(eyetype[i+1],9,12) then
    sw = sw*2.5
  else
    sw,sh = sw+line,sh+line
  end
local ln = line/2
obj.setoption("drawtarget","tempbuffer",sw,sh)

obj.load("figure","円",eyecl[i+1],s)
x=obj.w/2*px
y=obj.h/2*py
local ux,uy=obj.w,obj.h
local lx = (obj.w/2-ln)/2
local ly = (obj.h/2-ln)/2
obj.setoption("blend","alpha_max")
if(eyetype[i+1] == 1) then
obj.drawpoly(-x,ly-ln-y, 0,x,ly-ln-y, 0,x,ly-ln+y, 0,-x,ly-ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,ly+ln-y, 0,x,ly+ln-y, 0,x,ly+ln+y, 0,-x,ly+ln+y, 0)
elseif(eyetype[i+1] == 2) then
obj.drawpoly(-x,-ly+ln-y, 0,x,-ly+ln-y, 0,x,-ly+ln+y, 0,-x,-ly+ln+y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-x,-ly-ln-y, 0,x,-ly-ln-y, 0,x,-ly-ln+y, 0,-x,-ly-ln+y, 0)
elseif(eyetype[i+1] == 3) then
obj.drawpoly(-lx+ln-x*2,-y*3/4, 0,-lx+ln+x,-y*3/4, 0,-lx+ln+x,y*3/4, 0,-lx+ln-x*2,y*3/4, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x*2,-y*3/4, 0,-lx-ln+x,-y*3/4, 0,-lx-ln+x,y*3/4, 0,-lx-ln-x*2,y*3/4, 0)
elseif(eyetype[i+1] == 4) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(ln-x,ln-y, 0,x-ln,ln-y, 0,x-ln,y-ln, 0,ln-x,y, 0)
elseif(eyetype[i+1] == 5) then
obj.drawpoly(-lx+ln-x,-y, 0,-lx+ln+x,-y, 0,-lx+ln+x,y, 0,-lx+ln-x,y, 0)
obj.setoption("blend","alpha_sub")
obj.drawpoly(-lx-ln-x,-y, 0,-lx-ln+x,-y, 0,-lx-ln+x,y, 0,-lx-ln-x,y, 0)
elseif(eyetype[i+1] == 6) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
elseif(eyetype[i+1] == 7) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,-x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 8) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y-ln, 0,0,-y+y/8, 0,0,-y+y/8+line*1.5, 0,x*2.5,-y+ln,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 9) then
obj.drawpoly(-x,-y+y/8, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,uy/16,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,-x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(x/2,-y+y/4-ln, 0,-x/6,-y+y/4-ln, 0,-x/6,-y+y/4+ln, 0,x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 10) then
obj.drawpoly(-x,-y+y/4, 0,x,-y+y/8, 0,x,y,0,-x,y,0, 0,uy/8,ux,uy/16,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4-ln, 0,0,-y+y/4-ln, 0,0,-y+y/4+ln, 0,x*2.5,-y+y/4+ln, 0, 0,0,ux/2,0,ux/2,uy,0,uy)
obj.drawpoly(-x/2,-y+y/4-ln, 0,x/6,-y+y/4-ln, 0,x/6,-y+y/4+ln, 0,-x/2,-y+y/4+ln, 0, ux,0,ux/2,ux,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 11) then
obj.drawpoly(-x,-y+y/4, 0,x,-y, 0,x,y,0,-x,y,0, 0,uy/8,ux,0,ux,uy,0,uy)
obj.drawpoly(-x*2.5,-y+y/8+ln, 0,-x/6,-y+y/8, 0,-x/6,-y+y/8+line, 0,-x*2.5,-y+y/8+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 12) then
obj.drawpoly(-x,-y, 0,x,-y+y/4, 0,x,y,0,-x,y,0, 0,0,ux,uy/8,ux,uy,0,uy)
obj.drawpoly(x*2.5,-y+y/4+ln, 0,0,-y+y/8, 0,0,-y+y/8+line, 0,x*2.5,-y+y/4+ln*3,0, 0,0,ux/2,0,ux/2,uy,0,uy)
elseif(eyetype[i+1] == 13) then
obj.drawpoly(-x,-x/2, 0,x,-x/2, 0,x,x/2, 0,-x,x/2, 0)
elseif(eyetype[i+1] == 14) then
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
--真上
obj.drawpoly(-x*1.5,-y, 0,x*1.5,-y, 0,x*1.5,-y+line*2, 0,-x*1.5,-y+line*2, 0)
obj.drawpoly(-x*1.5,y-line*2, 0,x*1.5,y-line*2, 0,x*1.5,y, 0,-x*1.5,y, 0)
elseif(eyetype[i+1] == 15) then
obj.drawpoly(-y/4,-x/2, 0,y/4,-x/2, 0,y/4,x/2, 0,-y/4,x/2, 0)
else
obj.drawpoly(-x,-y, 0,x,-y, 0,x,y, 0,-x,y, 0)
end

obj.setoption("blend",0)
obj.setoption("drawtarget","framebuffer")
obj.load("tempbuffer")
--片目完成
local it = 2*i-1
local x=obj.w
local qy=obj.h/2
obj.effect()
qz,qx=anglepoint90((90-eyeang)*it,x+line)
epx,qz=eyemg/2*it,-qz
  if ( i == 0 ) then
	obj.drawpoly(epx-qx,-qy,-qz,epx+qx,-qy,qz,epx+qx,qy,qz,epx-qx,qy,-qz)
  else
	obj.effect("反転","左右反転",1)
	obj.drawpoly(epx+qx,-qy,qz,epx-qx,-qy,-qz,epx-qx,qy,-qz,epx+qx,qy,qz)
  end
end

@口
--track@A_t0:ライン幅,1,1000,20,1
--track@BN:分割数,1,50,20,1
--track@mouthtype:口の形状,0,12,0,1
--track@mtan:口内角度,-360,360,0
--check@audbuff:音声バッファ,0
--file@audioFile:音声ファイル
--check@lineonly:舌なし,0
--color@col:線色,0x000000
--color@col2:内部色,0x800000
--value@bufSize:データ数,32
--value@ttBuf:バッファ番号,15
--value@volUpper:音量(上),180
--value@volLower:音量(下),0
--value@valueUpper:開き具合(上),100
--value@valueLower:開き具合(下),0
--check@upperCut:上限カット,1
--check@lowerCut:下限カット,1
--check@maru:両端を丸める,0
--check@flip:左右反転,0
require("OCRuv")
if audbuff then audioFile="audiobuffer" end
volUpper = math.min(volUpper,8000)
volLower = math.max(volLower,0)
valueUpper = math.min(valueUpper,1000) / 100
valueLower = math.max(valueLower,0) / 100

if(volLower>volUpper) then
volave = volLower+volUpper/2
volLower = math.min(volave,8000)
volUpper = math.max(volave,0)
end
if(valueLower>valueUpper) then
valueave = valueLower+valueUpper/2
valueLower = math.min(valueave,1000)
valueUpper = math.max(valueave,0)
end

l=math.floor(A_t0)/2
mtds = 90
mouthsize = 100/2
NN=3
teethofi=0

path=obj.getinfo("script_path").."OCRUtil2.lua"
file=string.gsub(path,"\\","\\\\")
dofile(file) 

-- ■■■ 音量の取得と連動値の計算 ■■■
--if(audiolay>0) then
--audioFile = 
--end

-- getaudio()で取得するデータ数(1～1024)
bufSize=math.max(1, math.min(1024,math.floor(bufSize)))

-- 使用するバッファの番号
targetBuf=math.floor(ttBuf)

-- 音量データの取得
buf={}
num=obj.getaudio(buf, audioFile, "spectrum", bufSize)

-- numはbufSizeより小さくなる可能性があるとのことなので
-- 念のためそれにあわせてtargetBufが範囲内にあるかチェック。
targetBuf = math.max(1, math.min(num,math.floor(targetBuf)))

-- 必要に応じて、上限値や下限値でデータ値の足切りを行なう。
data = buf[targetBuf]
if (targetBuf ~= ttBuf) then
  data = (buf[targetBuf] + buf[targetBuf+1])/2
end
if (upperCut ~= 0) then -- 上限値を超えた値は上限値にそろえる
  data = math.min(volUpper,data)
end
if (lowerCut ~= 0) then -- 下限値より小さい値は下限値にそろえる
  data = math.max(volLower,data)
end

-- 連動データの単位変化量　(音量値あたりの連動データ値)
unit = (valueUpper-valueLower)/(volUpper-volLower)

-- 連動データ値の決定
val = (valueLower + (data - volLower) * unit)

-- ■■■ 連動値の適用 ■■■
pos={};teethpos={};
if(mouthtype == 1) then
--sm-a
pos={118,19-56*val,14+17*val,40+32*val,-66-20*val,14+33*val,-118-2*val,-43-33*val,-66+18*val,14-79*val,14+12*val,40-90*val,118,19-56*val}
--pos={118,-37,31,72,-86,47,-120,-76,-48,-65,36,-50,118,-37}
elseif(mouthtype == 2) then
--sm-i
pos={118-12*val,19+21*val,14-20*val,40+30*val,-66-38*val,14+13*val,-118+10*val,-43-18*val,-66+20*val,14-68*val,14+21*val,40-88*val,118+1*val,19-75*val}
--pos={106,40,-6,70,-104,27,-108,-61,-46,-54,35,-48,119,-56}
teethofi=1
	teethpos={114.39,-4.90,-114.69,-0.44}
elseif(mouthtype == 3) then
--sm-i
pos={106,40,-6,70,-104,27,-108,-61,-46,-54,35,-48,119,-56}
teethofi=1
	teethpos={114.39,-4.90,-114.69,-0.44}
elseif(mouthtype == 4) then
--sm-u,o
pos={118-89*val,19-7*val,14-11*val,40+22*val,-66+29*val,14+44*val,-118+78*val,-43+36*val,-66+52*val,14-63*val,14+11*val,40-84*val,118-89*val,19-7*val}
--pos={29,12,3,62,-37,58,-40,-7,-14,-49,25,-44,29,12}
elseif(mouthtype == 5) then
--sm-e
pos={118-12*val,19+21*val,14-20*val,40+30*val,-66-38*val,14+13*val,-118+10*val,-43-18*val,-66+20*val,14-68*val,14+21*val,40-88*val,118+1*val,19-75*val}
--pos={106,40,-6,70,-104,27,-108,-61,-46,-54,35,-48,119,-56}
mtds = 80
elseif(mouthtype == 6) then
--sm-n
pos={118,19,14,40,-66,14,-118,-43,-66,14,14,40,118,19}
teethofi=-1
elseif(mouthtype == 7) then
--fl-a
pos={115+5*val,28+48*val,49-18*val,-19+83*val,-43-17*val,-22+76*val,-120+1*val,18+28*val,-43+5*val,-22-45*val,49+28*val,-19-31*val,115+5*val,28+48*val}
--pos={120,76,31,64,-60,54,-119,46,-38,-67,77,-50,120,76}
elseif(mouthtype == 8) then
--fl-i
pos={115-6*val,28+25*val,49-16*val,-19+69*val,-43-16*val,-22+81*val,-120+4*val,18+57*val,-43-56*val,-22-9*val,49-57*val,-19-56*val,115+4*val,28-92*val}
--pos={109,53,33,50,-59,59,-116,75,-99,-31,-8,-75,119,-64}
teethofi=2
	teethpos={114.27,-2.10,-115.33,-3.5}
elseif(mouthtype == 9) then
--fl-i
pos={109,53,33,50,-59,59,-116,75,-99,-31,-8,-75,119,-64}
teethofi=2
	teethpos={114.27,-2.10,-115.33,-3.5}
elseif(mouthtype == 10) then
--fl-u,o
pos={115-86*val,28-16*val,49-46*val,-19+81*val,-43+6*val,-22+80*val,-120+80*val,18-25*val,-43+29*val,-22-27*val,49-24*val,-19-25*val,115-86*val,28-16*val}
--pos={29,12,3,62,-37,58,-40,-7,-14,-49,25,-44,29,12}
elseif(mouthtype == 11) then
--fl-e
pos={115-14*val,28+25*val,49-16*val,-19+69*val,-43-16*val,-22+81*val,-120+4*val,18+57*val,-43-56*val,-22-9*val,49-57*val,-19-56*val,115+4*val,28-92*val}
--pos={109,53,33,50,-59,59,-116,75,-99,-31,-8,-75,119,-64}
mtds = 80
elseif(mouthtype == 12) then
--fl-n
pos={115,28,49,-19,-43,-22,-120,18,-43,-22,49,-19,115,28}
teethofi=-1
--elseif(mouthtype == 13) then SD系もごもごととDonutは別で用意
else
pos={119-5*val,-8+49*val,49-20*val,-7+53*val,-62-13*val,1+30*val,-119,8-18*val,-62-29*val,1-41*val,49-54*val,-7-50*val,119-1*val,-8-44*val}
--pos={114,41,29,46,-75,31,-119,-10,-91,-40,-5,-57,118,-52}
mtds = 80
mouthsize = 90/2
end

if(val<=0 and mouthtype ~= 3 and mouthtype ~= 9) then
teethofi=-1
end

XX={}
YY={}
XX2={}
YY2={}
for i=0,3 do
  XX[i]=pos[2*i+1]
  YY[i]=pos[2*i+2]
  XX2[i]=pos[2*(6-i)+1]
  YY2[i]=pos[2*(6-i)+2]
end

Ax={};Bx={};Cx={};
Ay={};By={};Cy={};
Dx={};Ex={};Fx={};
Dy={};Ey={};Fy={};
for M=1,2 do
  Ax[M]=2*XX[M-1]-4*XX[M]+2*XX[M+1]
  Bx[M]=-3*XX[M-1]+4*XX[M]-XX[M+1]
  Cx[M]=XX[M-1]
  Ay[M]=2*YY[M-1]-4*YY[M]+2*YY[M+1]
  By[M]=-3*YY[M-1]+4*YY[M]-YY[M+1]
  Cy[M]=YY[M-1]
  Dx[M]=2*XX2[M-1]-4*XX2[M]+2*XX2[M+1]
  Ex[M]=-3*XX2[M-1]+4*XX2[M]-XX2[M+1]
  Fx[M]=XX2[M-1]
  Dy[M]=2*YY2[M-1]-4*YY2[M]+2*YY2[M+1]
  Ey[M]=-3*YY2[M-1]+4*YY2[M]-YY2[M+1]
  Fy[M]=YY2[M-1]
end

Nmax=3*BN

-- 仮想バッファサイズ計算
w = 0
h = 0
for i=0,3 do
  dx = math.ceil(math.abs(pos[i*2+1])+l+5+1)
  dy = math.ceil(math.abs(pos[i*2+2])+l+5+1)
  if( w < dx ) then w = dx end
  if( h < dy ) then h = dy end
  dx = math.ceil(math.abs(pos[(6-i)*2+1])+l+5+1)
  dy = math.ceil(math.abs(pos[(6-i)*2+2])+l+5+1)
  if( w < dx ) then w = dx end
  if( h < dy ) then h = dy end
end
obj.setoption("drawtarget","tempbuffer",w*2,h*2)
obj.setoption("blend","alpha_add")
ocr_fd={}
function drawfront(x0,y0,x1,y1,x2,y2,x3,y3)
	if(x0>x1) then
		sw = x0
		x0 = x1
		x1 = sw
		sw = y0
		y0 = y1
		y1 = sw
	end
	if(x2<x3) then
		sw = x2
		x2 = x3
		x3 = sw
		sw = y2
		y2 = y3
		y3 = sw
	end
	if(y0>y3) then
		sw = y0
		y0 = y3
		y3 = sw
		sw = x0
		x0 = x3
		x3 = sw
	end
	if(y2<y1) then
		sw = y2
		y2 = y1
		y1 = sw
		sw = x2
		x2 = x1
		x1 = sw
	end
	table.insert(ocr_fd,{x0,y0,0,x1,y1,0,x2,y2,0,x3,y3,0})
end

function anglepoint(px,py,angle,dist)
  local la = angle
  if ( la == nil ) then
    la = 0
  end
  local ar = math.rad(la)
  local ld = dist
  if ( ld == nil ) then
    ld = 0
  end
  dx,dy = px,py
  dx = px + math.sin(ar)*ld
  dy = py + math.cos(ar)*ld
  return dx,dy
end

if(teethofi>0) then
if(col==0xffffff) then
col=0x000000
end
col2=0xffffff
end

--内部描画
obj.load("figure","四角形",col2,1)
if(teethofi>=0) then
msz = mouthsize
x0,y0 = pos[7],pos[8]
x1,y1 = pos[7],pos[8]
ax,ay = anglepoint(0,0,mtan,mtds)
for i=1,Nmax do
  x2,y2 = PassXYZ(1-i/(NN*BN))
  x3,y3 = PassXYZ2(1-i/(NN*BN))
	drawfront(x0,y0,x2,y2,x3,y3,x1,y1)
	drawfront(x3,y3,x1,y1,x0,y0,x2,y2)
	drawfront(x2,y2,x3,y3,x1,y1,x0,y0)
	drawfront(x1,y1,x0,y0,x2,y2,x3,y3)
  x0 = x2
  y0 = y2
  x1 = x3
  y1 = y3
end
obj.drawpoly(ocr_filluv(ocr_fd,obj))
if( teethofi == 0 and lineonly == 0 ) then
  obj.load("figure","円",0xff80ff,msz*2)
  --obj.setoption("blend",6)
  obj.setoption("blend","alpha_add2")
  ax,ay = anglepoint(0,0,mtan,mtds)
  u0=0
  u1=obj.w
  v0=0
  v2=obj.h
  obj.drawpoly(ax-msz,ay-msz,0,ax+msz,ay-msz,0,ax+msz,ay+msz,0,ax-msz,ay+msz,0, u0,v0,u1,v0,u1,v2,u0,v2, 0.5)
end

--ライン描画
ocr_fd={}
obj.setoption("blend","alpha_mix")
obj.load("figure","四角形",col,1)
if( teethofi > 0 and lineonly == 0 ) then
x2,y2 = teethpos[1],teethpos[2]
x0,y0 = teethpos[3],teethpos[4]
x1,y1 = pos[1],pos[2]
x3,y3 = pos[13],pos[14]
  r = math.atan2(y0-y2,x2-x0)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x0-dx,y0-dy,0,x2-dx,y2-dy,0,x2+dx,y2+dy,0,x0+dx,y0+dy,0})
  r = math.atan2(y1-y3,x3-x1)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x1-dx,y1-dy,0,x3-dx,y3-dy,0,x3+dx,y3+dy,0,x1+dx,y1+dy,0})
end
else
obj.load("figure","四角形",col,1)
end

x0,y0 = pos[7],pos[8]
x1,y1 = pos[7],pos[8]
for i=1,Nmax do
  x2,y2 = PassXYZ(1-i/(NN*BN))
  x3,y3 = PassXYZ2(1-i/(NN*BN))
  r = math.atan2(y0-y2,x2-x0)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x0-dx,y0-dy,0,x2-dx,y2-dy,0,x2+dx,y2+dy,0,x0+dx,y0+dy,0})
  r = math.atan2(y1-y3,x3-x1)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x1-dx,y1-dy,0,x3-dx,y3-dy,0,x3+dx,y3+dy,0,x1+dx,y1+dy,0})
  x0 = x2
  y0 = y2
  x1 = x3
  y1 = y3
end
obj.drawpoly(ocr_filluv(ocr_fd,obj))

--頂点の描画
ocr_fd={}
obj.load("figure","円",col,l*8)
for i=1-maru,Nmax-1+maru do
  x0,y0 = PassXYZ(i/(NN*BN))
  table.insert(ocr_fd,{x0-l,y0-l,0,x0+l,y0-l,0,x0+l,y0+l,0,x0-l,y0+l,0})
  x0,y0 = PassXYZ2(i/(NN*BN))
  table.insert(ocr_fd,{x0-l,y0-l,0,x0+l,y0-l,0,x0+l,y0+l,0,x0-l,y0+l,0})
end
obj.drawpoly(ocr_filluv(ocr_fd,obj))
obj.setoption("blend",0)
obj.load("tempbuffer")
obj.effect()
  if ( flip == 1 ) then
    if (obj.ry > 0) then
      obj.effect("反転","左右反転",1)
    end
  else
    if (obj.ry <= 0) then
      obj.effect("反転","左右反転",1)
    end
  end
@口(ダイナミックモード)
--track@A_t0:ライン幅,1,1000,20,1
--track@BN:分割数,1,50,20,1
--track2:口の形状,0,12,0,1
--track@mtan:口内角度,-360,360,0
--check@audbuff:音声バッファ,0
--file@audioFile:音声ファイル
--check@lineonly:舌なし,0
--color@col:線色,0x000000
--color@col2:内部色,0x800000
--value@bufSize:データ数,32
--value@ttBuf:バッファ番号,15
--value@volUpper:音量(上),180
--value@volLower:音量(下),0
--value@valueUpper:開き具合(上),100
--value@valueLower:開き具合(下),0
--check@upperCut:上限カット,1
--check@lowerCut:下限カット,1
--check@maru:両端を丸める,0
--check@flip:左右反転,0
require("OCRuv")
if audbuff then audioFile="audiobuffer" end
volUpper = math.min(volUpper,8000)
volLower = math.max(volLower,0)
valueUpper = math.min(valueUpper,1000) / 100
valueLower = math.max(valueLower,0) / 100

if(volLower>volUpper) then
volave = volLower+volUpper/2
volLower = math.min(volave,8000)
volUpper = math.max(volave,0)
end
if(valueLower>valueUpper) then
valueave = valueLower+valueUpper/2
valueLower = math.min(valueave,1000)
valueUpper = math.max(valueave,0)
end

l=math.floor(A_t0)/2
mouthtype = {0,0}
mtds = {90,90}
mouthsize = {100/2,100/2}
NN=3
teethofi={0,0}

path=obj.getinfo("script_path").."OCRUtil2.lua"
file=string.gsub(path,"\\","\\\\")
dofile(file) 

mouthtype = {0,0}
track = readTrack(obj)
for i=0,1 do
mouthtype[i] = obj.getvalue(2,0,track[i])
end

-- ■■■ 音量の取得と連動値の計算 ■■■
--if(audiolay>0) then
--audioFile = 
--end

-- getaudio()で取得するデータ数(1～1024)
bufSize=math.max(1, math.min(1024,math.floor(bufSize)))

-- 使用するバッファの番号
targetBuf=math.floor(ttBuf)

-- 音量データの取得
buf={}
num=obj.getaudio(buf, audioFile, "spectrum", bufSize)

-- numはbufSizeより小さくなる可能性があるとのことなので
-- 念のためそれにあわせてtargetBufが範囲内にあるかチェック。
targetBuf = math.max(1, math.min(num,math.floor(targetBuf)))

-- 必要に応じて、上限値や下限値でデータ値の足切りを行なう。
data = buf[targetBuf]
if (targetBuf ~= ttBuf) then
  data = (buf[targetBuf] + buf[targetBuf+1])/2
end
if (upperCut ~= 0) then -- 上限値を超えた値は上限値にそろえる
  data = math.min(volUpper,data)
end
if (lowerCut ~= 0) then -- 下限値より小さい値は下限値にそろえる
  data = math.max(volLower,data)
end

-- 連動データの単位変化量　(音量値あたりの連動データ値)
unit = (valueUpper-valueLower)/(volUpper-volLower)

-- 連動データ値の決定
val = (valueLower + (data - volLower) * unit)

-- ■■■ 連動値の適用 ■■■
pos={};teethpos={};
_pos={{},{}};_teethpos={{},{}};
for i=0,1 do

if(mouthtype[i] == 1) then
--sm-a
_pos[i]={118,19-56*val,14+17*val,40+32*val,-66-20*val,14+33*val,-118-2*val,-43-33*val,-66+18*val,14-79*val,14+12*val,40-90*val,118,19-56*val}
elseif(mouthtype[i] == 2) then
--sm-i
_pos[i]={118-12*val,19+21*val,14-20*val,40+30*val,-66-38*val,14+13*val,-118+10*val,-43-18*val,-66+20*val,14-68*val,14+21*val,40-88*val,118+1*val,19-75*val}
teethofi[i]=1
	teethpos[i]={114.39,-4.90,-114.69,-0.44}
elseif(mouthtype[i] == 3) then
--sm-i
_pos[i]={106,40,-6,70,-104,27,-108,-61,-46,-54,35,-48,119,-56}
teethofi[i]=1
	teethpos[i]={114.39,-4.90,-114.69,-0.44}
elseif(mouthtype[i] == 4) then
--sm-u,o
_pos[i]={118-89*val,19-7*val,14-11*val,40+22*val,-66+29*val,14+44*val,-118+78*val,-43+36*val,-66+52*val,14-63*val,14+11*val,40-84*val,118-89*val,19-7*val}
elseif(mouthtype[i] == 5) then
--sm-e
_pos[i]={118-12*val,19+21*val,14-20*val,40+30*val,-66-38*val,14+13*val,-118+10*val,-43-18*val,-66+20*val,14-68*val,14+21*val,40-88*val,118+1*val,19-75*val}
mtds[i] = 80
elseif(mouthtype[i] == 6) then
--sm-n
_pos[i]={118,19,14,40,-66,14,-118,-43,-66,14,14,40,118,19}
teethofi[i]=-1
elseif(mouthtype[i] == 7) then
--fl-a
_pos[i]={115+5*val,28+48*val,49-18*val,-19+83*val,-43-17*val,-22+76*val,-120+1*val,18+28*val,-43+5*val,-22-45*val,49+28*val,-19-31*val,115+5*val,28+48*val}
elseif(mouthtype[i] == 8) then
--fl-i
_pos[i]={115-6*val,28+25*val,49-16*val,-19+69*val,-43-16*val,-22+81*val,-120+4*val,18+57*val,-43-56*val,-22-9*val,49-57*val,-19-56*val,115+4*val,28-92*val}
teethofi[i]=2
	teethpos[i]={114.27,-2.10,-115.33,-3.5}
elseif(mouthtype[i] == 9) then
--fl-i
_pos[i]={109,53,33,50,-59,59,-116,75,-99,-31,-8,-75,119,-64}
teethofi[i]=2
	teethpos[i]={114.27,-2.10,-115.33,-3.5}
elseif(mouthtype[i] == 10) then
--fl-u,o
_pos[i]={115-86*val,28-16*val,49-46*val,-19+81*val,-43+6*val,-22+80*val,-120+80*val,18-25*val,-43+29*val,-22-27*val,49-24*val,-19-25*val,115-86*val,28-16*val}
elseif(mouthtype[i] == 11) then
--fl-e
_pos[i]={115-14*val,28+25*val,49-16*val,-19+69*val,-43-16*val,-22+81*val,-120+4*val,18+57*val,-43-56*val,-22-9*val,49-57*val,-19-56*val,115+4*val,28-92*val}
mtds[i] = 80
elseif(mouthtype[i] == 12) then
--fl-n
_pos[i]={115,28,49,-19,-43,-22,-120,18,-43,-22,49,-19,115,28}
teethofi[i]=-1
--elseif(mouthtype[i] == 13) then SD系もごもごととDonutは別で用意
else
_pos[i]={119-5*val,-8+49*val,49-20*val,-7+53*val,-62-13*val,1+30*val,-119,8-18*val,-62-29*val,1-41*val,49-54*val,-7-50*val,119-1*val,-8-44*val}
mtds[i] = 80
mouthsize[i] = 90/2
end

if(val<=0 and mouthtype ~= 3 and mouthtype ~= 9) then
teethofi[i]=-2
end

end

pos=arrayMix(_pos[0],_pos[1],track[2],14)

XX={}
YY={}
XX2={}
YY2={}
for i=0,3 do
  XX[i]=pos[2*i+1]
  YY[i]=pos[2*i+2]
  XX2[i]=pos[2*(6-i)+1]
  YY2[i]=pos[2*(6-i)+2]
end

Ax={};Bx={};Cx={};
Ay={};By={};Cy={};
Dx={};Ex={};Fx={};
Dy={};Ey={};Fy={};
for M=1,2 do
  Ax[M]=2*XX[M-1]-4*XX[M]+2*XX[M+1]
  Bx[M]=-3*XX[M-1]+4*XX[M]-XX[M+1]
  Cx[M]=XX[M-1]
  Ay[M]=2*YY[M-1]-4*YY[M]+2*YY[M+1]
  By[M]=-3*YY[M-1]+4*YY[M]-YY[M+1]
  Cy[M]=YY[M-1]
  Dx[M]=2*XX2[M-1]-4*XX2[M]+2*XX2[M+1]
  Ex[M]=-3*XX2[M-1]+4*XX2[M]-XX2[M+1]
  Fx[M]=XX2[M-1]
  Dy[M]=2*YY2[M-1]-4*YY2[M]+2*YY2[M+1]
  Ey[M]=-3*YY2[M-1]+4*YY2[M]-YY2[M+1]
  Fy[M]=YY2[M-1]
end

Nmax=3*BN

-- 仮想バッファサイズ計算
w = 0
h = 0
for i=0,3 do
  dx = math.ceil(math.abs(pos[i*2+1])+l+5+1)
  dy = math.ceil(math.abs(pos[i*2+2])+l+5+1)
  if( w < dx ) then w = dx end
  if( h < dy ) then h = dy end
  dx = math.ceil(math.abs(pos[(6-i)*2+1])+l+5+1)
  dy = math.ceil(math.abs(pos[(6-i)*2+2])+l+5+1)
  if( w < dx ) then w = dx end
  if( h < dy ) then h = dy end
end
obj.setoption("drawtarget","tempbuffer",w*2,h*2)
obj.setoption("blend","alpha_add")

function drawfront(x0,y0,x1,y1,x2,y2,x3,y3)
	if(x0>x1) then
		sw = x0
		x0 = x1
		x1 = sw
		sw = y0
		y0 = y1
		y1 = sw
	end
	if(x2<x3) then
		sw = x2
		x2 = x3
		x3 = sw
		sw = y2
		y2 = y3
		y3 = sw
	end
	if(y0>y3) then
		sw = y0
		y0 = y3
		y3 = sw
		sw = x0
		x0 = x3
		x3 = sw
	end
	if(y2<y1) then
		sw = y2
		y2 = y1
		y1 = sw
		sw = x2
		x2 = x1
		x1 = sw
	end
	table.insert(ocr_fd,{x0,y0,0,x1,y1,0,x2,y2,0,x3,y3,0,0, obj.w,0, obj.w,obj.h, 0,obj.h})
end

function anglepoint(px,py,angle,dist)
  local la = angle
  if ( la == nil ) then
    la = 0
  end
  local ar = math.rad(la)
  local ld = dist
  if ( ld == nil ) then
    ld = 0
  end
  dx,dy = px,py
  dx = px + math.sin(ar)*ld
  dy = py + math.cos(ar)*ld
  return dx,dy
end
if(teethofi[0]==-1)
teethofi[0] = teethofi[1]
end
if(teethofi[0]>0) then
if(col==0xffffff) then
col=0x000000
end
col2=0xffffff
teethpos=arrayMix(_teethpos[0],_teethpos[1],track[2],4)
end

--内部描画
ocr_fd={}
obj.load("figure","四角形",col2,1)
if(teethofi[0]>=0) then
msz = valMix(mouthsize[0],mouthsize[1],track[2])
x0,y0 = pos[7],pos[8]
x1,y1 = pos[7],pos[8]
for i=1,Nmax do
  x2,y2 = PassXYZ(1-i/(NN*BN))
  x3,y3 = PassXYZ2(1-i/(NN*BN))
	drawfront(x0,y0,x2,y2,x3,y3,x1,y1)
	drawfront(x3,y3,x1,y1,x0,y0,x2,y2)
	drawfront(x2,y2,x3,y3,x1,y1,x0,y0)
	drawfront(x1,y1,x0,y0,x2,y2,x3,y3)
  x0 = x2
  y0 = y2
  x1 = x3
  y1 = y3
end
obj.drawpoly(ocr_fd)
if( teethofi[0] == 0 and lineonly == 0 ) then
  obj.load("figure","円",0xff80ff,msz*2)
  obj.setoption("blend","alpha_add2")
  ax,ay = anglepoint(0,0,mtan,valMix(mtds[0],mtds[1],track[2]))
  u0=0
  u1=obj.w
  v0=0
  v2=obj.h
  obj.drawpoly(ax-msz,ay-msz,0,ax+msz,ay-msz,0,ax+msz,ay+msz,0,ax-msz,ay+msz,0, u0,v0,u1,v0,u1,v2,u0,v2, 0.5)
end

--ライン描画
ocr_fd={}
obj.setoption("blend","alpha_mix")
obj.load("figure","四角形",col,1)
local fdw,fdh = obj.w,obj.h

if( teethofi[0] > 0 and lineonly == 0 ) then
x2,y2 = teethpos[1],teethpos[2]
x0,y0 = teethpos[3],teethpos[4]
x1,y1 = pos[1],pos[2]
x3,y3 = pos[13],pos[14]
  r = math.atan2(y0-y2,x2-x0)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x0-dx,y0-dy,0,x2-dx,y2-dy,0,x2+dx,y2+dy,0,x0+dx,y0+dy,0,0, fdw,0, fdw,fdh, 0,fdh})
  r = math.atan2(y1-y3,x3-x1)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x1-dx,y1-dy,0,x3-dx,y3-dy,0,x3+dx,y3+dy,0,x1+dx,y1+dy,0,0, fdw,0, fdw,fdh, 0,fdh})
end
else
obj.load("figure","四角形",col,1)
end

x0,y0 = pos[7],pos[8]
x1,y1 = pos[7],pos[8]
for i=1,Nmax do
  x2,y2 = PassXYZ(1-i/(NN*BN))
  x3,y3 = PassXYZ2(1-i/(NN*BN))
  r = math.atan2(y0-y2,x2-x0)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x0-dx,y0-dy,0,x2-dx,y2-dy,0,x2+dx,y2+dy,0,x0+dx,y0+dy,0,0, fdw,0, fdw,fdh, 0,fdh})
  r = math.atan2(y1-y3,x3-x1)
  dx = math.sin(r)*l
  dy = math.cos(r)*l
  table.insert(ocr_fd,{x1-dx,y1-dy,0,x3-dx,y3-dy,0,x3+dx,y3+dy,0,x1+dx,y1+dy,0,0, fdw,0, fdw,fdh, 0,fdh})
  x0 = x2
  y0 = y2
  x1 = x3
  y1 = y3
end
obj.drawpoly(ocr_fd)
--頂点の描画
ocr_fd={}
obj.load("figure","円",col,l*8)
for i=1-maru,Nmax-1+maru do
  x0,y0 = PassXYZ(i/(NN*BN))
  table.insert(ocr_fd,{x0-l,y0-l,0,x0+l,y0-l,0,x0+l,y0+l,0,x0-l,y0+l,0,0, fdw,0, fdw,fdh, 0,fdh})
  x0,y0 = PassXYZ2(i/(NN*BN))
  table.insert(ocr_fd,{x0-l,y0-l,0,x0+l,y0-l,0,x0+l,y0+l,0,x0-l,y0+l,0,0, fdw,0, fdw,fdh, 0,fdh})
end
obj.drawpoly(ocr_fd)
obj.setoption("blend",0)
obj.load("tempbuffer")
obj.effect()
  if ( flip == 1 ) then
    if (obj.ry > 0) then
      obj.effect("反転","左右反転",1)
    end
  else
    if (obj.ry <= 0) then
      obj.effect("反転","左右反転",1)
    end
  end
